## Chapter 1
I got no further than the first sentence in the preface before I had to stop and ask a question. The quote that struck me so hard was "The gap between the best software engineering practice and the average practice is very wide, perhaps wider than in any other engineering discipline. A tool that disseminates good practice would be important." Fred Brooks 
Which left me to ask "If AI is trained from community knowledge, and the average practice in software engineering is of such low quality, is AI being trained to be a low-quality programmer?" From there, I got to thinking that if all you have to offer is something produced by an AI, why should a company hire you instead of just turning to that same AI?
Don't get me wrong, I definitely see the advantages of AI, and believe that anyone who does not use AI will eventually be left behind. But I also believe that if all you do is us AI to churn out everything with little to no thought or effort on your part, then there is nothing stopping you from being replaced by that same AI you are using as a crutch. 
From there, the other thing that stood out was just how many non-coding related activities there are in software development. 

According to the author, I am not sure I qualify as the target audience for Code complete. I don't care. 
I want to learn how to think like a programmer, and I set a goal to become a master programmer, and for me that will involve a deep dive into studying programming to figure out how programmers think … or maybe it might be better to say how I want to think as a programmer. Given the gap between the best practices and the common practices of programming, and the likelihood of that gap widening as result of AI and especially vibe coding, learning how I should think as a software engineer, will be critical in achieving my goal. And with how my brain thrives off of knowledge, diving in as deeply as I am planning, even into a book I might not be ready to dive into, is going to be a good thing. 

If I had to take a guess, based on just how hard it is to learn good practices (based on what Code Complete says) then I would bet that once I finish learning things like software architecture in a few books, I will likely start to see patterns for how everything ties together. And if I don't automatically find those patterns, then I am certain I will find them when I go back for the 3rd run through all of the books. I feel good about this journey. It is going to fill in a lot of gaps for me. 

From my prior experience on places like stack overflow (which admittedly is limited) it seems that programmers are terrible at sharing things online, and when you do get places dedicated towards the idea, it seems to become so full of arrogance that you cannot even ask a simple question, and when you do meet their unrealistic standards for even being able to ask a question, you find people completely ignoring the question you ask, and answering something else entirely, and even voting down an answer that shares a direct answer to the question being asked. 
And while that is only one community, the lack of any other book as comprehensive as Code Complete, and the lack of any one viable place to go online especially as a beginner, says to me there is a gap in the software development industry, and while (assuming my limited experience in places like StackOverflow) it might ruffle a few feathers, maybe those feathers need to be ruffled a bit. 

As I was composing my list of questions to dive deeper into the topics covered in the preface and chapter 1 of Code Complete, I kept having one question pop into my mind. At first I wanted to find a nicer way of wording the question, but then I just realized I already know the answer. The question (worded bluntly) is "Why do so many companies create environments where taking shortcuts on quality is not only acceptable, but almost forced?" And really the answer is the same thing that causes problems I have with the stock market, too many people are too short sighted for their own good and that nature because of the difference between software engineering and other types of more physical engineering. For example, if I build a piece of buggy code then I can just release a patch for it later. But, if I build a poorly designed bridge then people are going to die. One of the things I had to stop and research into when going through the chapter the first time, was to discover what went into those coding projects where only 30% of the time was spent coding verses those projects where 80% was spent coding, and the difference ended up being that for those industries where people's lives are at risk, they take fewer shortcuts, and spend more time making sure they got things right. So, essentially, when they don't have to, people, like the electricity that powers the computers they write code on, take the path of least resistance. 

Questions to ponder and/or research
Why do so many areas of coding end up so often neglected?
What are the habits of new programmers that lead them to success compared to the habits of those who fail and leave the industry?
What habits do I need to develop if I am to become a master software engineer?
What habits do I need to break and drop like a bad habit if I am to become a master software engineer?

From an industry perspective, what knowledge/skills are required to thrive in the following areas of software construction: 
Problem definition
Requirements Development
Construction planning
Software architecture or high-level design
Detailed design
Coding and debugging
Unit testing
Integration testing
Integration
System testing
Corrective maintenance

Also, are there any other areas of software development that might have developed over the last 2 decades since Code Complete was last updated?
How do I create a culture where shortcuts are frowned upon as a matter of habit? Would that really be the best path, or would there be a happy medium somewhere in the middle? Or are things truly better as they currently are? From the race between Microsoft and Apple, the company who got things out first won. Microsoft won the Operating system wars despite (based on the perspective of Steve Jobs) having an inferior and buggier product. First is not always the winner. Sometimes they just open the door for someone else later. 
I guess another area connected with this is consumer expectation. For example, my poetry, even when fed hundreds of my poems, from my perspective, an AI is incapable of replicating my style. But from the perspective of someone who cares far less about a product, an AI might be able to easily replicate my style and even surpass it. If I am to create a culture of mastery, what all do I need to change? It sounds like consumer expectations might be part of what I would need to change as well. Then again, maybe I just don't have enough information. All good questions to ponder. 

## Chapter 2 thoughts
The first thing I want to write about is something I did not learn at all in any of the 5 classes I took on computer programming. You first build the simplest version of the program you can, and then from there, you slowly develop the program to include more functional versions of the code. As I read about this concept, I realized that is what I should have done when trying to build my first Kotlin app in school. Instead of trying to build the whole app all at once, you build just a basic console app that does the same thing. Then you modify it to slowly turn it into a full-fledged Android App. And seeing how software development works, I can see the power in that process. 

Another thing this chapter taught me was how to finally understand and apply the idea of abstraction. I first take and create a metaphor of the problem I am trying to solve. From there, I use the process of creating the metaphor to then pull out the basic elements of the problem. I don't remember how they tried to teach the concept in school, but that was one I never got until reading this chapter. 

The idea of teaching software through use of metaphor leaves me happy that I chose to write my book, because to create a metaphor, I generally need a much higher level of understanding about a topic, and that is what I will gain through this journey. 

This chapter was exclusively about introducing metaphors to the software development process, and spent most of the time explaining different metaphors that describe the software development process. The one he favored most was the construction analogy. 

A Heuristic is something that teaches you how to find the solution. 
An Algorithm gives you specific instructions on how to solve the problem. 

Thinking about this a little more, I realize that the same thing that has been holding me back in software development was the same thing that was holding me back in planning, I was trying to take complex idea and boil it instantly down into a complete program. That is not the way it works. I need to go step by step. If you are an explorer, stepping into the unknown, you don't have a map, so you can't know the whole path. But if you know where you are trying to get and a few things about where you are headed, then you can figure several things out. For example, take Lewis and Clark. They wanted to find a path to the Pacific Ocean. They knew generally how far they needed to go, and they knew they needed to go west, but they had to figure everything else out as they went. The same thing can be said about building a computer program when you are just learning, or planning something you have never done. Figure out what you can, figure out what success looks like, and then plan out just enough to take the next step. Break down the problem into smaller manageable parts, and then plan enough to take the next move forward. 

## Chapter 3 Thoughts
I'm about halfway through with my first reading of chapter 3. There is a lot to digest from this chapter. Funny enough, most of the things I am getting are from the parts where he talks about the things he has no intention of discussing. For example, he talks about the idea of how critical figuring out the requirements of the software you are going to build is, and gives you some tools to figure out how to tell if you have done a good job at determining the requirements, but specifically (and repeatedly) says that he has no intention of going into the actual process of getting good requirements in the first place. My first impression as I looked at the list of easily 2 dozen things to check to see if you have properly gone through the process of ensuring you have collected good requirements for your project was to be amazed at the size and scope of the list. 
It does not take much to figure out why software requirements are so critical to get. They are the goal post you use to figure out if you are done, and the idea that the only way to ensure that the requirements do not change is to ignore your client, to me suggests that the whole industry is lacking on its ability to collect information. Honestly, just thinking about what little I know about software development and the reality that customers are not always right, customers never have a clue about the real problem they are dealing with, if I had to suggest a process for collecting software requirements it would look something like this. 
    1. Get a lead software developer out of the office and have them go spend a week or so at their client's business seeing what their needs are. Engage with them, come prepared with a list of questions to literally assault the client with. This must be someone who understands how software development actually works and who would be involved in the process of building the software. 
    2. From there, after you know better what their current work environment is like, then sit down in their office, with the client, working out the details to what they might want in the software you are going to build for them. Record this whole meeting. 
    3. Transcribe everything, even the stupid ideas that someone said should be thrown out, and then turn that into a simple to read report that you discuss in another meeting, including the stupid ideas, and collect any new ideas that are brought up. 
    4. From there, you create a rough draft report of what you want to do, including creating mockups for the software, and present your plan for the software to the customer. Make any additional revisions. 
    5. Create a final draft of the requirements for the software. 
    6. Every step in this process should involve a real discussion between the client and the lead programmer with a goal of being able to both encourage ideas and give a rough idea of what is and is not possible and at least a ballpark guess about the potential time and costs involved. (This is why it needs to be someone who knows the programming process)
    7. Give final cost estimates and final draft of requirements for software. 

Will that be a perfect way to collect the requirements? No. Nothing will. But by going into their workspace, and getting to know and see their processes, and having a brainstorming session right there, you can ensure that you have the best possible situation to collect ideas and needs. Additionally by having someone familiar with the development process, you can give at least a ballpark idea of what you are realistically looking at for time and costs before the bean counters get involved. 
Another thing that stood out to me in the chapter was the idea of different projects needing different kind of planning. The two methods of development talked about in the chapter so far are iterative and sequential (or waterfall). What stood out to me about the iterative method is that you use it when you are not sure how to build the whole project. There are whole entire planning methodologies surrounding the idea of planning for something you do not know how to build. That is rather cool. Of course, now that I have gotten over my block, I realize that what it likely boils down to is you plan what you can to get going, then come back at a predetermined point in time (like just before you anticipate running out of work from the first plan) then expand it out with what you have learned. 
So, applying that to my Ministering Planning Board, that I have put on the back burner for now, I would first build just a console version of the app. Likely one that would just assume I just finished assigning everyone, and then see how much I could build in a console version. From there, expand it out into a more graphical version later, stopping to both review and plan things as I go … and likely learning a few things along the way. 
Wow! If I have gained this many insights from just two and a half chapters, just imagine what I will gain from reading the rest of the book and the other 8 books I am going to go through afterwards. Then imagine how much I will learn as I start to build things (like my ministering board project) along the way. And then imagine how much I will learn as I finally compile all of this into a book. 
This is going to be fun!

## Chapter 3 Final Thoughts

The last half of chapter 3 was mostly about architecture. The book is definitely meant for someone with more experience in the industry than I have. I still don't care. I'm having fun reading it and learning a ton. I am also excellent at learning from context. In some ways, I am happy I am reading it, because I get to take what he describes as the ideal, reverse engineer it in my mind to what makes sense, and all without being burdened by preconceptions of how to get there. Additionally, the book I am trying to write is not necessarily about how to become a master coder, but how to think about software development, something that is holding me back from getting started in it. Maybe that will change by the time I get done, but right now I am happily digesting everything. 
At first as I read about the things that should be in the software architecture I had the impression that it was like a plan for the software. But as I got in deeper to the chapter, I realized it also seemed to contain rules and such almost like it were a set of governing laws for the program you are about to build. From there, as I got in even deeper, it almost felt like the software architect would need to build the whole program in his mind, without ever writing a single line of code which touches on the roadblock that I ran into with trying to figure out how to plan. I suppose that is why so many people seem to think that learning software architecture is something reserved for experienced programmers. Honestly, with all the questions in my mind about software architecture, I am half tempted to read it next, or even put my current book down and read the architecture book right now. I can figure out the parts I am missing. But, at the same time, I see the wisdom in waiting, and in reality, know I will enjoy the rest of this book and the four books I have to read between this one and the architecture book. I think the reason I want to skip ahead so much is the idea that to master architecture I need to learn how to do something that previously paralyzed me completely, and finding whatever demon is hiding behind that and completely annihilating it will be fun. But, I already made a reading plan, and the software architecture book will be getting read in April 2026 so, wherever that demon can keep hiding wherever it is currently hiding but come April 2026, I get to squish it like a bug … assuming I haven't starved it out before then. 
Another thing that stands out to me is the level of planning work that is involved in proper software development. The title of the chapter is one I have heard many times measure twice cut once. In construction, if you cut a board too short, you have to throw the board out. So, it is better to spend a bit more time making sure you got just the right measurement, both on the board and the space it is going to go in, before cutting it and then needing to buy a whole new two-by-four. That leaves me wondering, how different would the software development world be if the moment we wrote a line of code, it could never be changed, and thus we had to completely throw it away if we messed up? 
The chapter has a pyramid with 3 things that all come before you write a single line of code. Defining the problem, mapping the requirements, and planning and defining the architecture. From there comes software construction, system testing, and then finally future improvements. 
The problem needs to be defined clearly, and worded in the form of a problem, in whatever language you and your team speak. As simple as that might be, knowing clearly what kind of problem you are solving would be critical to getting is solved. I suppose, it would also be critical to planning everything else. How can you solve a problem if you don't know what it is? As I stop to think about this, simple model is useful in more than just learning the overall roadmap for a software project. 
I sit down to work at my first programming job, before I just start coding, I need to define the problem I am going to be solving. From there, I need to figure out how to know when I have solved it. Set up the plan for how I am going to solve it, including identifying potential risks that might come, and from there, I can actually start to write the software. I then, if I am going to truly care about my work, will test the code I wrote, to make sure it works the way I wanted it to. Would you write an email and send it off to your boss without proofreading it? What if that email could cost your company thousands? What if that email would literally affect everyone in your company? Then why would you just write code, not check it, and send it through to the next guy? That little pyramid is a simple diagram showing the ideal day in the life of a software developer. That is cool. Obviously, reality will likely be different than the ideal, but if I want to thrive, then I cannot wait for the world to hand me what I need, I have to carve it out and fight for it. 
I know there is something about the architecture that I am missing from the short 38 pages of this chapter. It seems like a gloriously complex topic. I will likely have a conversation with an AI about it to dive in a little more. This is fun. 
I just had a short conversation with an AI about architecture, and already figured out part of what I have been doing wrong for planning code. I keep trying to think in terms of how will the code look. I don't need to think in terms of code at all. I just need to follow the wonderful pyramid I learned about. I first define the problem, then I figure out what it needs to look like at the end, and from there, I create the best set of rules and such that I can to help me get an idea of how to get from problem to solution. Whether, I am designing a brand new built from scratch operating system, a single class in that operating system, the first chapter in the book I am planning to write, or anything else, that same pattern will apply. From there, once I get that plan in place, I take action, and can worry about any improvements later. 
So when building software architecture, I am not thinking in terms of coding at all, I am thinking in terms of the problem, the solution, and then how to get from point A to point B. I don't need to know anything about a binary search tree to build the plan, I just need to be able to get to know the problem and solution well enough to build a roadmap of how to get there, and the same thing can apply to every single problem I try to solve. 
I just fell in love with that simple triangle. I knew I was missing something big, and I just found it.


## Code Complete Chapter 4 Thoughts
### First Thoughts
The first thoughts I had while reading this chapter have little to do with the contents of the chapter but more generally processing everything I have read so far, including in this chapter and thinking about how to best put it into use. 
Programming is about solving problems using computers. So, if I am going to become a professional and high paid problem solver, then I need to create a set of habits that help me step into that role. The thing that was holding me back at first was getting stuck in the weeds of whatever language I was hoping to use/learn for that project, and not focusing on the problem. Problems, like algorithms existed long before computers existed. Thus, before I can become a master problem solver who happens to use computers as my primary source of solving problems, I need to first become a master problem solver. The Planning Pyramid I discovered yesterday is a good place to start, and I can use my Ministering Planning Board project as a good place to start. 
For the first step, I would just need something to write with and a way to brainstorm the problem I am trying to solve. I have an idea of what I want the end to look like, but I have never taken the time to truly ponder the problem. Fine I saw the problem in play and that is what sparked the idea, but I never really took the time to actually write down the problem. So, step 1 Describe the problem. In this case, the planning process for ministering is annoying and requires the need to wastefully use paper that has had names written (often by hand) on it, and that is taped to a 3 fold board for display. To make matters worse, when done, if multiple people need copies of the board, then only one can get the actual work, the rest just have to take pictures with the cameras, and if the papers have been folded or are overlapping, then it is incredibly easy to not be able to see all of the names on the board for those who have to use the pictures of the board. In short, the current system for planning ministering is cumbersome and not friendly for having multiple people enter it into the computer. 
Step 2, describe the solution. I think I did well at that previously, so for now, I will just add that user story I wrote here, that contains the description of what I want it to look like when done. I might go back and review what makes good requirements and see how my user story meets that, but for now, this works. (All names of people are made up. While Lehi is a real city, the ward name is made up, the church name is real, but this work is not authorized by them it is an individual project)
User Story
The Elders Quorum Presidency of the Lehi 1,000th ward of the Church of Jesus Christ of Latter-day Saints, is gathering for their quarterly planning meeting. The first councilor in the presidency could not be there directly, but they got him on Zoom, and plan to share the screen of the computer they are doing all the work on today so he can participate too. 
They pull up the Digital Ministering Planning Tool and get to work. This is their first time using the software as a presidency, but the Elder's Quorum President already figured out how the software works, and was happy with how easy it is to use. He clicks the import list button at the top, selects the CSV file with all of the names of the people in their ward on it, and then it populates those names into two different lists; Ministers and Children of God. 
From there, they create 4 Districts. One assigned to each member of the presidency, along with a 4th that they leave unassigned to place all of those individuals who do not wish to be contacted or others with special circumstances in. After that, they start creating ministering companionships. They click and drag the first name John Avast on the list to the first district, and then after discussing who they want for his companion and settle on Samual Shatterhorn, they drag Samuel's name unto John's and that instantly forms a new companionship. After continuing that process for a while, the presidency realizes that Thomas Dixon, is a new convert and has expressed concerns about his ability to be a minister. After discussing their options, they decide to add Thomas to the companionship between John and Samuel, and so they just drag Thomas's name onto their companionship and his name is added to that companionship, for a total of three people in that companionship. 
From there, after they finish creating all of the companionships, they notice that there is an alert on the 3rd district and upon checking it, they notice that it has 3 more companionships than each of the other two. They discuss and pray about who if anyone they should move, and ultimately leave it as is and mark the alert as completed. They also notice that district 4 had a bunch of alerts from the individuals that they put into that district without even assigning them to a companionship, so they just marked the whole column as ignore on the alerts, and moved onto assigning people to be ministered to. 
The first family on the list, the Alsen's is a family who is constantly struggling, they think about the power that both John and Samual would bring to the table and realize that having someone to help might also help Thomas, but they could also see him being overwhelmed by the idea, but they really feel strongly about the idea of assigning the Alsen's to be ministered to by John and Samuel, so they drag the Alsen family's card onto their companionship and that creates a formal ministering assignment. The Alsen Family has a pair of twins that just turned 8 and have not been baptized, and their oldest son, is almost 18 and just barely graduated high school, so they add a flag for each of those individuals, and to that ministering assignment, and then add a note to the assignment to remind the Presidency to check up on Thomas frequently to make sure he will be fine. 
After finishing creating all of the assignments, they decide that they want a password on the list, so they enable that feature, save the file to a locally stored file, and email a copy to each member of the Presidency. When they select the print button, the default option is to create a presidency list, that contains spots to mark for when each companionship has been interviewed on it, along with any notes or flags they added, and then a companionship list, that has lists which are both easily printed and cut up to be physically given out. They notice an option to email the list, and find that they could email using any major email client, but decide to print the list instead because they want to talk to the companionships before they just send them their lists. 
The next quarter, when they meet up again to update ministering assignments, they load up their file, enter the password to open it, import a list of new members who moved in, and remove anyone who moved out from the list, which the update list feature made it easy to do. From there, they decide that their concerns about Thomas were justified, but they love the idea of the Alsen Family working with John and Samual. They then remember that Thomas seemed to be good friends with Mike Finsler, so they make them a companionship and assign them to visit with one of the new families that just moved into the ward. They decide to leave them with just that one family. In the process, they ended up assigning one companionship 6 families to minister to, and that created a flag. They realize that would be too many for one companionship to minister to, make a few adjustments, and then email out their new lists to everyone. 
Finally go to leave, but the website warns them that they have not saved. They quickly save the file. The save dialog asks them if they want to keep the password the same or update it. They choose to keep it the same and check the box to not be reminded again. 

Step 3
Thinking about this step, this is the one that threw me off the most before, and for an understandable reason. I was not properly building up to the step. Given my goal of creating a detailed plan, and the newly written problem, and the insights I gained from actually taking the time to write it out, I think, before I can create a proper plan, I need to turn my user story into a more digestible list of features. From there, I would pick a feature, go back to step 1, create a problem statement for what problem I am trying to solve for that feature, then define what success would look like when I got that problem solved, and from there, I could map out a way to solve that particular feature. I would then repeat that for each feature in my master requirements list, updating it as needed along the way. From there, I have suddenly built a plan for my whole software program. If I were working on a team, I would then go and break things out into different groups and assign them out to different people/teams to work on, and suddenly I have a plan for a whole program. I think for my needs, I want to include notes in my code detailing the problem I am trying to solve, the goal I am trying to meet, and any additional concerns I have for building it along the way. Then I can reference it and keep that in mind as I build. 

Step 4
I build the program. Given my current skills, this would likely involve learning a ton of things along the way, but I would be armed with much better questions because I would better understand what I am actually trying to achieve. This is AWESOME!!!!!!!!! I just went from being paralyzed by the very idea of trying to do this, to having a solid and simple to follow roadmap to help me do that right now if I wanted. I love that little problem solving pyramid. 
I am so happy I decided to take the time to proceed forward in a manner that respects my needs. I would have struggled for months to get to this point had I just kept pushing the way everyone else wanted me to. 

### Second Readthrough thoughts
While I wouldn't say the chapter is devoid of information, quite the contrary in fact, the chapter for me, even after going through it a second time, left me with a simple and powerful insight, one applied from numerous areas of life. Life will always have its struggles. I subscribe to a platform called GrowthDay, where millionaires and billionaires share insights into how they succeeded in various areas of life. From this chapter, I learned the same lesson I learned from watching dozens of courses on GrowthDay. It doesn't matter where you are at in life, there will always be struggles. There is no magical point where you suddenly become problem free. You have to fight to make your life what you want and the moment you quit those habits, that is moment you start to lose. In life that means you start the process that will lead to your job being first on the chopping block. In programming, that means you will start to produce lower quality code and then from there, you will eventually lose that cushy programming job too. And even if by some chance you can guarantee the company won't fire you, eventually that company will go out of business and then you will still be out of a job. Don't just work with what you have, make what you have work for you. If you don't, you'll be left a slave to the whims of whatever the universe decides to throw at you. 

Choosing to take the path of learning first, is what helped me get this massive breakthrough. I've had a serious win already. I told Deanne that the win I had today was worthy of a Super Awesome mega Who's awesome chant. However, when I committed to this path of learning, I committed to it as a way to honor my needs and my strengths, literally for the first time in my life. So, while I might be tempted to say "Yay! I got past my roadblock!" And then run off to go follow the path the world thinks I should, what kind of message would I be sending me, if I did? I don't like the answer to that question. My next step, I continue my promise to me, and in the process, I get to find out what kind of transformation I will see when I have finished writing my book in likely 2 to 5 years. However, I also realize, that I need to do more than just learning. And while trying to write a book is doing something, it is one thing to learn a powerful problem solving pyramid through that study, it is another to put what I learn into practice. So, as I continue to follow this promise I gave to me, I am also going to carve out time to apply everything I am learning to the point where it all becomes second nature. The world will see my worth when God is ready for them to see it. Beyond that, I don't care. 

## Code Complete Chapter 5
### Initial thoughts 
#### Part 1
Wow! Programming is gloriously complex! One of the big things that stood out to me about design is the idea that in design there is no right answer, and that often it is about making tradeoffs and compromises. The thing I walked away from that whole section was the idea that for this part of software development, you need to be able to thrive in an environment that just last week, had me paralyzed when initially facing. As I stop to think about it, life is one big massive unknown problem after another and it is something that leaves a ton of people paralyzed. Success in life in general, not just in programming, requires you to be good at life throwing you curve balls. I work in Tech Support right now, and realize that the only reason I got to where I'm at has nothing to do with me knowing every possible scenario I could possibly run into, but knowing how to figure it out. I constantly run into things I've never ran into before. I literally just ran into a situation I had never ran into before just today, and after I got past the customer's objections, I was able to use my well-developed professional guess to find a solution rather quickly. So, the fact that I can do that in tech support so easily, means that I just need to get over myself, develop a broader base of knowledge to pull from (which I am doing right now) and then have confidence in my skill of being able to figure it out as I go. Will I be perfect? Never. That's not the goal. I just need to believe in myself and keep learning. From there, everything else will fall into place. 

#### Part 2
The computer programming course I struggled with most in school was my Programming with Classes. Looking back, I see the reason why, I just had so many unanswered questions. And right now, I am getting insights that might have changed my experience in that same class. For example, the idea of Encapsulation. What's the big deal? Who really cares whether something is hidden or not? Well, one answer to those questions comes with the idea of change. My dad had a saying that I have grown to love, "Learn to make change the stability you rely on." I think that the computer programming world would do well to adopt that saying as a way of life. If we assumed everything could change, and built it with that in mind, then how much easier to maintain would our software be? If we put almost everything in classes, hiding away as much as we could, then could we also generate error codes that told us which class generated the error? If that is possible, how much easier would it be to figure out how to fix our software bugs? There is an incredible amount of knowledge hidden away beyond the syntax of the language we use to write our code in. 

#### Part 3
There is a wealth of information hiding in chapter 5, really in programming knowledge in general. You have a wealth of resources to help you solve problems better. You have design patterns to help you better structure and organize the architecture of your program, and algorithms to help you better implement the individual parts of your program, and between the two, you have an almost ready made solution to a vast majority of problems you might run into, yet, too often we turn to copying and pasting code we likely don't understand from places like StackOverflow or now AI. I want to ask why, but I know why. Humans are the electricity powering the computers we program on, we take the path of least resistance. The difference between us and electricity is that we can choose a different path. We can choose a different nature, and when we do, we find a path to a better and more influential world. 
