## Chapter 1
I got no further than the first sentence in the preface before I had to stop and ask a question. The quote that struck me so hard was "The gap between the best software engineering practice and the average practice is very wide, perhaps wider than in any other engineering discipline. A tool that disseminates good practice would be important." Fred Brooks 
Which left me to ask "If AI is trained from community knowledge, and the average practice in software engineering is of such low quality, is AI being trained to be a low-quality programmer?" From there, I got to thinking that if all you have to offer is something produced by an AI, why should a company hire you instead of just turning to that same AI?
Don't get me wrong, I definitely see the advantages of AI, and believe that anyone who does not use AI will eventually be left behind. But I also believe that if all you do is us AI to churn out everything with little to no thought or effort on your part, then there is nothing stopping you from being replaced by that same AI you are using as a crutch. 
From there, the other thing that stood out was just how many non-coding related activities there are in software development. 

According to the author, I am not sure I qualify as the target audience for Code complete. I don't care. 
I want to learn how to think like a programmer, and I set a goal to become a master programmer, and for me that will involve a deep dive into studying programming to figure out how programmers think … or maybe it might be better to say how I want to think as a programmer. Given the gap between the best practices and the common practices of programming, and the likelihood of that gap widening as result of AI and especially vibe coding, learning how I should think as a software engineer, will be critical in achieving my goal. And with how my brain thrives off of knowledge, diving in as deeply as I am planning, even into a book I might not be ready to dive into, is going to be a good thing. 

If I had to take a guess, based on just how hard it is to learn good practices (based on what Code Complete says) then I would bet that once I finish learning things like software architecture in a few books, I will likely start to see patterns for how everything ties together. And if I don't automatically find those patterns, then I am certain I will find them when I go back for the 3rd run through all of the books. I feel good about this journey. It is going to fill in a lot of gaps for me. 

From my prior experience on places like stack overflow (which admittedly is limited) it seems that programmers are terrible at sharing things online, and when you do get places dedicated towards the idea, it seems to become so full of arrogance that you cannot even ask a simple question, and when you do meet their unrealistic standards for even being able to ask a question, you find people completely ignoring the question you ask, and answering something else entirely, and even voting down an answer that shares a direct answer to the question being asked. 
And while that is only one community, the lack of any other book as comprehensive as Code Complete, and the lack of any one viable place to go online especially as a beginner, says to me there is a gap in the software development industry, and while (assuming my limited experience in places like StackOverflow) it might ruffle a few feathers, maybe those feathers need to be ruffled a bit. 

As I was composing my list of questions to dive deeper into the topics covered in the preface and chapter 1 of Code Complete, I kept having one question pop into my mind. At first I wanted to find a nicer way of wording the question, but then I just realized I already know the answer. The question (worded bluntly) is "Why do so many companies create environments where taking shortcuts on quality is not only acceptable, but almost forced?" And really the answer is the same thing that causes problems I have with the stock market, too many people are too short sighted for their own good and that nature because of the difference between software engineering and other types of more physical engineering. For example, if I build a piece of buggy code then I can just release a patch for it later. But, if I build a poorly designed bridge then people are going to die. One of the things I had to stop and research into when going through the chapter the first time, was to discover what went into those coding projects where only 30% of the time was spent coding verses those projects where 80% was spent coding, and the difference ended up being that for those industries where people's lives are at risk, they take fewer shortcuts, and spend more time making sure they got things right. So, essentially, when they don't have to, people, like the electricity that powers the computers they write code on, take the path of least resistance. 

Questions to ponder and/or research
Why do so many areas of coding end up so often neglected?
What are the habits of new programmers that lead them to success compared to the habits of those who fail and leave the industry?
What habits do I need to develop if I am to become a master software engineer?
What habits do I need to break and drop like a bad habit if I am to become a master software engineer?

From an industry perspective, what knowledge/skills are required to thrive in the following areas of software construction: 
Problem definition
Requirements Development
Construction planning
Software architecture or high-level design
Detailed design
Coding and debugging
Unit testing
Integration testing
Integration
System testing
Corrective maintenance

Also, are there any other areas of software development that might have developed over the last 2 decades since Code Complete was last updated?
How do I create a culture where shortcuts are frowned upon as a matter of habit? Would that really be the best path, or would there be a happy medium somewhere in the middle? Or are things truly better as they currently are? From the race between Microsoft and Apple, the company who got things out first won. Microsoft won the Operating system wars despite (based on the perspective of Steve Jobs) having an inferior and buggier product. First is not always the winner. Sometimes they just open the door for someone else later. 
I guess another area connected with this is consumer expectation. For example, my poetry, even when fed hundreds of my poems, from my perspective, an AI is incapable of replicating my style. But from the perspective of someone who cares far less about a product, an AI might be able to easily replicate my style and even surpass it. If I am to create a culture of mastery, what all do I need to change? It sounds like consumer expectations might be part of what I would need to change as well. Then again, maybe I just don't have enough information. All good questions to ponder. 

## Chapter 2 thoughts
The first thing I want to write about is something I did not learn at all in any of the 5 classes I took on computer programming. You first build the simplest version of the program you can, and then from there, you slowly develop the program to include more functional versions of the code. As I read about this concept, I realized that is what I should have done when trying to build my first Kotlin app in school. Instead of trying to build the whole app all at once, you build just a basic console app that does the same thing. Then you modify it to slowly turn it into a full-fledged Android App. And seeing how software development works, I can see the power in that process. 

Another thing this chapter taught me was how to finally understand and apply the idea of abstraction. I first take and create a metaphor of the problem I am trying to solve. From there, I use the process of creating the metaphor to then pull out the basic elements of the problem. I don't remember how they tried to teach the concept in school, but that was one I never got until reading this chapter. 

The idea of teaching software through use of metaphor leaves me happy that I chose to write my book, because to create a metaphor, I generally need a much higher level of understanding about a topic, and that is what I will gain through this journey. 

This chapter was exclusively about introducing metaphors to the software development process, and spent most of the time explaining different metaphors that describe the software development process. The one he favored most was the construction analogy. 

A Heuristic is something that teaches you how to find the solution. 
An Algorithm gives you specific instructions on how to solve the problem. 

Thinking about this a little more, I realize that the same thing that has been holding me back in software development was the same thing that was holding me back in planning, I was trying to take complex idea and boil it instantly down into a complete program. That is not the way it works. I need to go step by step. If you are an explorer, stepping into the unknown, you don't have a map, so you can't know the whole path. But if you know where you are trying to get and a few things about where you are headed, then you can figure several things out. For example, take Lewis and Clark. They wanted to find a path to the Pacific Ocean. They knew generally how far they needed to go, and they knew they needed to go west, but they had to figure everything else out as they went. The same thing can be said about building a computer program when you are just learning, or planning something you have never done. Figure out what you can, figure out what success looks like, and then plan out just enough to take the next step. Break down the problem into smaller manageable parts, and then plan enough to take the next move forward. 

## Chapter 3 Thoughts
I'm about halfway through with my first reading of chapter 3. There is a lot to digest from this chapter. Funny enough, most of the things I am getting are from the parts where he talks about the things he has no intention of discussing. For example, he talks about the idea of how critical figuring out the requirements of the software you are going to build is, and gives you some tools to figure out how to tell if you have done a good job at determining the requirements, but specifically (and repeatedly) says that he has no intention of going into the actual process of getting good requirements in the first place. My first impression as I looked at the list of easily 2 dozen things to check to see if you have properly gone through the process of ensuring you have collected good requirements for your project was to be amazed at the size and scope of the list. 
It does not take much to figure out why software requirements are so critical to get. They are the goal post you use to figure out if you are done, and the idea that the only way to ensure that the requirements do not change is to ignore your client, to me suggests that the whole industry is lacking on its ability to collect information. Honestly, just thinking about what little I know about software development and the reality that customers are not always right, customers never have a clue about the real problem they are dealing with, if I had to suggest a process for collecting software requirements it would look something like this. 
    1. Get a lead software developer out of the office and have them go spend a week or so at their client's business seeing what their needs are. Engage with them, come prepared with a list of questions to literally assault the client with. This must be someone who understands how software development actually works and who would be involved in the process of building the software. 
    2. From there, after you know better what their current work environment is like, then sit down in their office, with the client, working out the details to what they might want in the software you are going to build for them. Record this whole meeting. 
    3. Transcribe everything, even the stupid ideas that someone said should be thrown out, and then turn that into a simple to read report that you discuss in another meeting, including the stupid ideas, and collect any new ideas that are brought up. 
    4. From there, you create a rough draft report of what you want to do, including creating mockups for the software, and present your plan for the software to the customer. Make any additional revisions. 
    5. Create a final draft of the requirements for the software. 
    6. Every step in this process should involve a real discussion between the client and the lead programmer with a goal of being able to both encourage ideas and give a rough idea of what is and is not possible and at least a ballpark guess about the potential time and costs involved. (This is why it needs to be someone who knows the programming process)
    7. Give final cost estimates and final draft of requirements for software. 

Will that be a perfect way to collect the requirements? No. Nothing will. But by going into their workspace, and getting to know and see their processes, and having a brainstorming session right there, you can ensure that you have the best possible situation to collect ideas and needs. Additionally by having someone familiar with the development process, you can give at least a ballpark idea of what you are realistically looking at for time and costs before the bean counters get involved. 
Another thing that stood out to me in the chapter was the idea of different projects needing different kind of planning. The two methods of development talked about in the chapter so far are iterative and sequential (or waterfall). What stood out to me about the iterative method is that you use it when you are not sure how to build the whole project. There are whole entire planning methodologies surrounding the idea of planning for something you do not know how to build. That is rather cool. Of course, now that I have gotten over my block, I realize that what it likely boils down to is you plan what you can to get going, then come back at a predetermined point in time (like just before you anticipate running out of work from the first plan) then expand it out with what you have learned. 
So, applying that to my Ministering Planning Board, that I have put on the back burner for now, I would first build just a console version of the app. Likely one that would just assume I just finished assigning everyone, and then see how much I could build in a console version. From there, expand it out into a more graphical version later, stopping to both review and plan things as I go … and likely learning a few things along the way. 
Wow! If I have gained this many insights from just two and a half chapters, just imagine what I will gain from reading the rest of the book and the other 8 books I am going to go through afterwards. Then imagine how much I will learn as I start to build things (like my ministering board project) along the way. And then imagine how much I will learn as I finally compile all of this into a book. 
This is going to be fun!

## Chapter 3 Final Thoughts

The last half of chapter 3 was mostly about architecture. The book is definitely meant for someone with more experience in the industry than I have. I still don't care. I'm having fun reading it and learning a ton. I am also excellent at learning from context. In some ways, I am happy I am reading it, because I get to take what he describes as the ideal, reverse engineer it in my mind to what makes sense, and all without being burdened by preconceptions of how to get there. Additionally, the book I am trying to write is not necessarily about how to become a master coder, but how to think about software development, something that is holding me back from getting started in it. Maybe that will change by the time I get done, but right now I am happily digesting everything. 
At first as I read about the things that should be in the software architecture I had the impression that it was like a plan for the software. But as I got in deeper to the chapter, I realized it also seemed to contain rules and such almost like it were a set of governing laws for the program you are about to build. From there, as I got in even deeper, it almost felt like the software architect would need to build the whole program in his mind, without ever writing a single line of code which touches on the roadblock that I ran into with trying to figure out how to plan. I suppose that is why so many people seem to think that learning software architecture is something reserved for experienced programmers. Honestly, with all the questions in my mind about software architecture, I am half tempted to read it next, or even put my current book down and read the architecture book right now. I can figure out the parts I am missing. But, at the same time, I see the wisdom in waiting, and in reality, know I will enjoy the rest of this book and the four books I have to read between this one and the architecture book. I think the reason I want to skip ahead so much is the idea that to master architecture I need to learn how to do something that previously paralyzed me completely, and finding whatever demon is hiding behind that and completely annihilating it will be fun. But, I already made a reading plan, and the software architecture book will be getting read in April 2026 so, wherever that demon can keep hiding wherever it is currently hiding but come April 2026, I get to squish it like a bug … assuming I haven't starved it out before then. 
Another thing that stands out to me is the level of planning work that is involved in proper software development. The title of the chapter is one I have heard many times measure twice cut once. In construction, if you cut a board too short, you have to throw the board out. So, it is better to spend a bit more time making sure you got just the right measurement, both on the board and the space it is going to go in, before cutting it and then needing to buy a whole new two-by-four. That leaves me wondering, how different would the software development world be if the moment we wrote a line of code, it could never be changed, and thus we had to completely throw it away if we messed up? 
The chapter has a pyramid with 3 things that all come before you write a single line of code. Defining the problem, mapping the requirements, and planning and defining the architecture. From there comes software construction, system testing, and then finally future improvements. 
The problem needs to be defined clearly, and worded in the form of a problem, in whatever language you and your team speak. As simple as that might be, knowing clearly what kind of problem you are solving would be critical to getting is solved. I suppose, it would also be critical to planning everything else. How can you solve a problem if you don't know what it is? As I stop to think about this, simple model is useful in more than just learning the overall roadmap for a software project. 
I sit down to work at my first programming job, before I just start coding, I need to define the problem I am going to be solving. From there, I need to figure out how to know when I have solved it. Set up the plan for how I am going to solve it, including identifying potential risks that might come, and from there, I can actually start to write the software. I then, if I am going to truly care about my work, will test the code I wrote, to make sure it works the way I wanted it to. Would you write an email and send it off to your boss without proofreading it? What if that email could cost your company thousands? What if that email would literally affect everyone in your company? Then why would you just write code, not check it, and send it through to the next guy? That little pyramid is a simple diagram showing the ideal day in the life of a software developer. That is cool. Obviously, reality will likely be different than the ideal, but if I want to thrive, then I cannot wait for the world to hand me what I need, I have to carve it out and fight for it. 
I know there is something about the architecture that I am missing from the short 38 pages of this chapter. It seems like a gloriously complex topic. I will likely have a conversation with an AI about it to dive in a little more. This is fun. 
I just had a short conversation with an AI about architecture, and already figured out part of what I have been doing wrong for planning code. I keep trying to think in terms of how will the code look. I don't need to think in terms of code at all. I just need to follow the wonderful pyramid I learned about. I first define the problem, then I figure out what it needs to look like at the end, and from there, I create the best set of rules and such that I can to help me get an idea of how to get from problem to solution. Whether, I am designing a brand new built from scratch operating system, a single class in that operating system, the first chapter in the book I am planning to write, or anything else, that same pattern will apply. From there, once I get that plan in place, I take action, and can worry about any improvements later. 
So when building software architecture, I am not thinking in terms of coding at all, I am thinking in terms of the problem, the solution, and then how to get from point A to point B. I don't need to know anything about a binary search tree to build the plan, I just need to be able to get to know the problem and solution well enough to build a roadmap of how to get there, and the same thing can apply to every single problem I try to solve. 
I just fell in love with that simple triangle. I knew I was missing something big, and I just found it.