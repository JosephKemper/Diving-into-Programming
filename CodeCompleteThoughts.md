## Chapter 1
I got no further than the first sentence in the preface before I had to stop and ask a question. The quote that struck me so hard was "The gap between the best software engineering practice and the average practice is very wide, perhaps wider than in any other engineering discipline. A tool that disseminates good practice would be important." Fred Brooks 
Which left me to ask "If AI is trained from community knowledge, and the average practice in software engineering is of such low quality, is AI being trained to be a low-quality programmer?" From there, I got to thinking that if all you have to offer is something produced by an AI, why should a company hire you instead of just turning to that same AI?
Don't get me wrong, I definitely see the advantages of AI, and believe that anyone who does not use AI will eventually be left behind. But I also believe that if all you do is us AI to churn out everything with little to no thought or effort on your part, then there is nothing stopping you from being replaced by that same AI you are using as a crutch. 
From there, the other thing that stood out was just how many non-coding related activities there are in software development. 

According to the author, I am not sure I qualify as the target audience for Code complete. I don't care. 
I want to learn how to think like a programmer, and I set a goal to become a master programmer, and for me that will involve a deep dive into studying programming to figure out how programmers think … or maybe it might be better to say how I want to think as a programmer. Given the gap between the best practices and the common practices of programming, and the likelihood of that gap widening as result of AI and especially vibe coding, learning how I should think as a software engineer, will be critical in achieving my goal. And with how my brain thrives off of knowledge, diving in as deeply as I am planning, even into a book I might not be ready to dive into, is going to be a good thing. 

If I had to take a guess, based on just how hard it is to learn good practices (based on what Code Complete says) then I would bet that once I finish learning things like software architecture in a few books, I will likely start to see patterns for how everything ties together. And if I don't automatically find those patterns, then I am certain I will find them when I go back for the 3rd run through all of the books. I feel good about this journey. It is going to fill in a lot of gaps for me. 

From my prior experience on places like stack overflow (which admittedly is limited) it seems that programmers are terrible at sharing things online, and when you do get places dedicated towards the idea, it seems to become so full of arrogance that you cannot even ask a simple question, and when you do meet their unrealistic standards for even being able to ask a question, you find people completely ignoring the question you ask, and answering something else entirely, and even voting down an answer that shares a direct answer to the question being asked. 
And while that is only one community, the lack of any other book as comprehensive as Code Complete, and the lack of any one viable place to go online especially as a beginner, says to me there is a gap in the software development industry, and while (assuming my limited experience in places like StackOverflow) it might ruffle a few feathers, maybe those feathers need to be ruffled a bit. 

As I was composing my list of questions to dive deeper into the topics covered in the preface and chapter 1 of Code Complete, I kept having one question pop into my mind. At first I wanted to find a nicer way of wording the question, but then I just realized I already know the answer. The question (worded bluntly) is "Why do so many companies create environments where taking shortcuts on quality is not only acceptable, but almost forced?" And really the answer is the same thing that causes problems I have with the stock market, too many people are too short sighted for their own good and that nature because of the difference between software engineering and other types of more physical engineering. For example, if I build a piece of buggy code then I can just release a patch for it later. But, if I build a poorly designed bridge then people are going to die. One of the things I had to stop and research into when going through the chapter the first time, was to discover what went into those coding projects where only 30% of the time was spent coding verses those projects where 80% was spent coding, and the difference ended up being that for those industries where people's lives are at risk, they take fewer shortcuts, and spend more time making sure they got things right. So, essentially, when they don't have to, people, like the electricity that powers the computers they write code on, take the path of least resistance. 

Questions to ponder and/or research
Why do so many areas of coding end up so often neglected?
What are the habits of new programmers that lead them to success compared to the habits of those who fail and leave the industry?
What habits do I need to develop if I am to become a master software engineer?
What habits do I need to break and drop like a bad habit if I am to become a master software engineer?

From an industry perspective, what knowledge/skills are required to thrive in the following areas of software construction: 
Problem definition
Requirements Development
Construction planning
Software architecture or high-level design
Detailed design
Coding and debugging
Unit testing
Integration testing
Integration
System testing
Corrective maintenance

Also, are there any other areas of software development that might have developed over the last 2 decades since Code Complete was last updated?
How do I create a culture where shortcuts are frowned upon as a matter of habit? Would that really be the best path, or would there be a happy medium somewhere in the middle? Or are things truly better as they currently are? From the race between Microsoft and Apple, the company who got things out first won. Microsoft won the Operating system wars despite (based on the perspective of Steve Jobs) having an inferior and buggier product. First is not always the winner. Sometimes they just open the door for someone else later. 
I guess another area connected with this is consumer expectation. For example, my poetry, even when fed hundreds of my poems, from my perspective, an AI is incapable of replicating my style. But from the perspective of someone who cares far less about a product, an AI might be able to easily replicate my style and even surpass it. If I am to create a culture of mastery, what all do I need to change? It sounds like consumer expectations might be part of what I would need to change as well. Then again, maybe I just don't have enough information. All good questions to ponder. 

## Chapter 2 thoughts
The first thing I want to write about is something I did not learn at all in any of the 5 classes I took on computer programming. You first build the simplest version of the program you can, and then from there, you slowly develop the program to include more functional versions of the code. As I read about this concept, I realized that is what I should have done when trying to build my first Kotlin app in school. Instead of trying to build the whole app all at once, you build just a basic console app that does the same thing. Then you modify it to slowly turn it into a full-fledged Android App. And seeing how software development works, I can see the power in that process. 

Another thing this chapter taught me was how to finally understand and apply the idea of abstraction. I first take and create a metaphor of the problem I am trying to solve. From there, I use the process of creating the metaphor to then pull out the basic elements of the problem. I don't remember how they tried to teach the concept in school, but that was one I never got until reading this chapter. 

The idea of teaching software through use of metaphor leaves me happy that I chose to write my book, because to create a metaphor, I generally need a much higher level of understanding about a topic, and that is what I will gain through this journey. 

This chapter was exclusively about introducing metaphors to the software development process, and spent most of the time explaining different metaphors that describe the software development process. The one he favored most was the construction analogy. 

A Heuristic is something that teaches you how to find the solution. 
An Algorithm gives you specific instructions on how to solve the problem. 

Thinking about this a little more, I realize that the same thing that has been holding me back in software development was the same thing that was holding me back in planning, I was trying to take complex idea and boil it instantly down into a complete program. That is not the way it works. I need to go step by step. If you are an explorer, stepping into the unknown, you don't have a map, so you can't know the whole path. But if you know where you are trying to get and a few things about where you are headed, then you can figure several things out. For example, take Lewis and Clark. They wanted to find a path to the Pacific Ocean. They knew generally how far they needed to go, and they knew they needed to go west, but they had to figure everything else out as they went. The same thing can be said about building a computer program when you are just learning, or planning something you have never done. Figure out what you can, figure out what success looks like, and then plan out just enough to take the next step. Break down the problem into smaller manageable parts, and then plan enough to take the next move forward. 

## Chapter 3 Thoughts
I'm about halfway through with my first reading of chapter 3. There is a lot to digest from this chapter. Funny enough, most of the things I am getting are from the parts where he talks about the things he has no intention of discussing. For example, he talks about the idea of how critical figuring out the requirements of the software you are going to build is, and gives you some tools to figure out how to tell if you have done a good job at determining the requirements, but specifically (and repeatedly) says that he has no intention of going into the actual process of getting good requirements in the first place. My first impression as I looked at the list of easily 2 dozen things to check to see if you have properly gone through the process of ensuring you have collected good requirements for your project was to be amazed at the size and scope of the list. 
It does not take much to figure out why software requirements are so critical to get. They are the goal post you use to figure out if you are done, and the idea that the only way to ensure that the requirements do not change is to ignore your client, to me suggests that the whole industry is lacking on its ability to collect information. Honestly, just thinking about what little I know about software development and the reality that customers are not always right, customers never have a clue about the real problem they are dealing with, if I had to suggest a process for collecting software requirements it would look something like this. 
    1. Get a lead software developer out of the office and have them go spend a week or so at their client's business seeing what their needs are. Engage with them, come prepared with a list of questions to literally assault the client with. This must be someone who understands how software development actually works and who would be involved in the process of building the software. 
    2. From there, after you know better what their current work environment is like, then sit down in their office, with the client, working out the details to what they might want in the software you are going to build for them. Record this whole meeting. 
    3. Transcribe everything, even the stupid ideas that someone said should be thrown out, and then turn that into a simple to read report that you discuss in another meeting, including the stupid ideas, and collect any new ideas that are brought up. 
    4. From there, you create a rough draft report of what you want to do, including creating mockups for the software, and present your plan for the software to the customer. Make any additional revisions. 
    5. Create a final draft of the requirements for the software. 
    6. Every step in this process should involve a real discussion between the client and the lead programmer with a goal of being able to both encourage ideas and give a rough idea of what is and is not possible and at least a ballpark guess about the potential time and costs involved. (This is why it needs to be someone who knows the programming process)
    7. Give final cost estimates and final draft of requirements for software. 

Will that be a perfect way to collect the requirements? No. Nothing will. But by going into their workspace, and getting to know and see their processes, and having a brainstorming session right there, you can ensure that you have the best possible situation to collect ideas and needs. Additionally by having someone familiar with the development process, you can give at least a ballpark idea of what you are realistically looking at for time and costs before the bean counters get involved. 
Another thing that stood out to me in the chapter was the idea of different projects needing different kind of planning. The two methods of development talked about in the chapter so far are iterative and sequential (or waterfall). What stood out to me about the iterative method is that you use it when you are not sure how to build the whole project. There are whole entire planning methodologies surrounding the idea of planning for something you do not know how to build. That is rather cool. Of course, now that I have gotten over my block, I realize that what it likely boils down to is you plan what you can to get going, then come back at a predetermined point in time (like just before you anticipate running out of work from the first plan) then expand it out with what you have learned. 
So, applying that to my Ministering Planning Board, that I have put on the back burner for now, I would first build just a console version of the app. Likely one that would just assume I just finished assigning everyone, and then see how much I could build in a console version. From there, expand it out into a more graphical version later, stopping to both review and plan things as I go … and likely learning a few things along the way. 
Wow! If I have gained this many insights from just two and a half chapters, just imagine what I will gain from reading the rest of the book and the other 8 books I am going to go through afterwards. Then imagine how much I will learn as I start to build things (like my ministering board project) along the way. And then imagine how much I will learn as I finally compile all of this into a book. 
This is going to be fun!
